## Function

### threshold()

```python
cv.threshold(src, thresh, maxval, type[, dst]) -> retval, dst
```

- Parameters
  - src	    输入的原图像，多通道
  - thresh   阈值
  - maxval  执行TRESH_BINARY操作和THRESH_BINARY_INV时用于给图像数组的赋值
  - type       阈值操作算法，枚举
- Returns
  - retval     阈值，在TRESH_BINARY等操作下于参数thresh一致，只有执行的阈值算法为OTSU等时才有实际意义
  - dst         图像数组，存放图像操作结果
- Type Enumerator
  - cv.THRESH_BINARY    大于阈值置为maxval,否则置为0
  - cv.THRESH_BINARY_INV    与前者相反
  - cv.THRESH_TRUNC    大于阈值置为thresh，否则保留原值
  - cv.THRESH_TOZERO    大于阈值保留原值，否则置为0
  - cv.THRESH_TOZERO_INV    与前者相反
  - cv.THRESH_OTSU    大津法
    1. 灰度化
    2. 计算灰度直方图
    3. 对于0-255，遍历每个值作为阈值T，小于等于阈值的像素为背景，否则为前景
    4. 计算背景占比w0，前景占比w1，背景像素平均值u0, 前景像素平均值u1
    5. 计算类间方差g[T] = w0w1(u0-u1)^2
    6. 找到最大的类间方差对应的T，即为所求最佳阈值
    7. 利用所求阈值进行二值化处理
  - cv.THRESH_TRIANGLE     三角法
    1. 灰度化
    2. 计算灰度直方图
    3. 寻找直方图两侧边界
    4. 寻找直方图最大值
    5. 检测最大值是否处于亮面，否则反转
    6. 计算阈值
       1. 灰度直方图中，自出现的最小的灰度值的点bmin到最高峰bmax点构造一条直线
       2. 在灰度图中，寻找一点，使得点到直线的距离最大(遍历求解)，记为点bl
       3. 点bl对应的灰度即为所求的阈值T，注意，如果标记需要反转，则阈值为255-T
    7. 利用所求阈值进行二值化处理
- Notes
  - 阈值操作对于噪声敏感，通常会先进行高斯滤波
  - OTSU和TRIANGLE可搭配BINARY等一起使用


### Canny()

- Algorithm

  1. 灰度化

  2. 高斯滤波

  3. 差分计算

     使用**Sobel算子**进行梯度的方向和幅值的计算

     - Y方向
       $$
       S_y = \left[\matrix{1&2&1\\0&0&0\\-1&-2&-2}\right]
       $$

     - X方向
       $$
       S_x=\left[\matrix{1&0&-1\\2&0&2\\1&0&-1}\right]
       $$

     - 计算方式

       分别使用Y方向算子和X方向算子对原图像矩阵进行卷积运算

       1. 180°旋转算子

       2. 对每个原图像矩阵每个像素，将其和算子中心(卷积核)重合，每个像素值和算子值相乘后全部相加，得到该点X,Y方向的梯度

       3. 移动卷积核，对每个像素进行卷积运算，最终得到$Y$方向的梯度矩阵$G_y$和$X$方向的梯度矩阵$G_x$

       4. 计算每个点的梯度幅值，得到梯度幅值矩阵，公式为$G_c = \sqrt{G_x^2+G_y^2}$，然而为了计算方便，实际运算时经常使用$G_c = |G_x|+|G_y| $

       5. 计算每个点的梯度方向，$\theta=|arctan(G_y/G_x)|$

  4. 非极大值抑制

     1. 将梯度方向简化为4个方向，分别是水平方向，垂直方向，45°方向和135°方向

        简化方法

        - 水平方向    $\theta_M \in [67.5, 112.5] \cup [-112.5, -67.5)$
        - 垂直方向    $\theta_M \in [0, 22.5) \cup (-22.5, 0] \cup (157.5, 180] \cup (-180, 157.5]$
        - 45°方向    $\theta_M \in [22.5, 67.5) \cup [-157.5, -112.5)$
        - 135°方向    $\theta_M \in (112,5, 157,5] \cup [-67.5, -22.5]$

     2. 对简化后的梯度方向上的两领域进行比较，如果中心像素的梯度幅值为最大值则保留，否则中心像素像素值置为0

  5. 双阈值检测

     1. 选取系数$T_H$和$T_L$，通常二者比值为2或者3
     2. 对于每个像素的梯度幅值，和两个系数相比较，如果大于$T_H$，置为255，标记为强边缘，如果小于$T_L$，置为0，标记为弱边缘。

  6. 边缘连通

     采用深度优先算法

     1. 准备一个栈s，一个队列q，设联通指示变量connected为假。从图像的第一个点开始，进入2。
     2. 如果这个点是弱边界点并且没有被标记，把它标记，并把它作为第一个元素放入栈s中，同时把它放入记录连通曲线的队列q，进入3。如果这个点不是弱边界或者已经被标记过，到图像的下一个点，重复2。
     3. 从栈s中取出一个元素，查找它的8像素领域。如果一个领域像素是弱边界并且没有被标记过，把这个领域像素标记，并加入栈s中，同时加入队列q。同时查找领域对应的强边界图，如果有一个像素是强边界，表示这条弱边界曲线和强边界联通，设置connected为真。重复3直到栈中没有元素了。如果connected为假，则依次从队列q中取出每个元素，清空标记。如果connected为真，保留标记。
     4. 清空队列q，设置connected为假，移动到图像的下一个点，到2。

     

- Code

  ```python
  cv,Canny(image, threshold1, threshold2[,edges=null[,apertureSize=3[, L2gradient=False]]]) -> edges
  ```

- Parameters

  - image    输入的原图像，8bit单通道灰度图
  - threshold1    进行双阈值检测的较高值
  - threshold2    进行双阈值检测的较低值
  - edges    存放结果的数组
  - apertureSize    Sobel算子的大小
  - L2gradient    flag，如果为Ture，则计算梯度幅值时采用平方和开方法，否则采用绝对值相加法。

- Returns

  - edges    检测出的边缘的单通道8bit图像，和原始图像尺寸相同

### HoughCircles()

- Algorithm

  核心是使用霍夫梯度法获取圆心和半径

  1. 对图像采用Canny边缘检测，同时获得每个前景点的梯度
  2. 对图像的每个点设立一个累加器vote
  3. 对边缘图像的每个前景点，由斜率和点指定一条直线，计算直线上每个和前景点的距离介于给定最大半径和给定最小半径的点的累加器+1.
  4. 筛选累加器值不为0的所有点，筛选条件为累加器值大于给定阈值，且为邻域内最大，将筛选出的点降序排列，标记为中心。
  5. 对每个中心点，考虑每个前景点，计算距离并遍历，最后获取最支持的一条半径
  6. 此时保留该中心点和其距离，作为结果等待输出，同时排除所有和该中心点距离小于给出阈值的中心点

- Code

  ```python
  cv.HoughCircles(image, method, dp, minDist[, circles = null[, param1=100[, param2=100[, minRadius=0[, maxRadius=0]]]]]) ->	circles
  ```

- Parameters

  - image    输入的原图像，8bit单通道灰度图
  - method    霍夫圆变化采用的方法，此处仅可用cv.HOUGH_GRADIENT
  - dp    原图像和累加器处理图像的分辨率之比，例如dp=2是累加器处理的图像分辨率将是原图的二分之一
  - minDist    算法步骤6中的给定阈值，用于标记圆心和圆心间的最小距离
  - circles    用于存储返回值的特化数组，详细查看返回值
  - param1    算法步骤1中调用Canny边缘检测时传递的参数，是Canny双阈值中较高的阈值，较低的阈值将是param1的一半
  - param2    算法步骤4中的给定阈值，用于筛选可能的圆心
  - minRadius    算法步骤3中的给定最小半径，用于限定半径大小
  - maxRadius    算法步骤3中的给定最大半径，用于限定半径大小，当=0时，使用图像最大尺寸，若<0，则返回值将不含查找的半径

- Returns

  - circles    存储返回圆心和半径的特化数组，数组中的每个元素都是一个含有3个或4个元素的数组，这个数组的组成为(x, y, radius[, votes])，当maxRadius<0时，radius将被置为0
